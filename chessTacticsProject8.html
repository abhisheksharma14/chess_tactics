<!DOCTYPE HTML>
<html>
	<head>
		<title>Chess Tactics</title>
		<link rel=stylesheet type="text/css" href="chessboard.css">
		<script src="chessboard-0.3.0.js"></script>
		<script src="json3.min.js"></script>
		<script src="jquery-1.10.1.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.js"></script>
		<script>
		var tactics = [
				['6k1/5p1p/4p1p1/2p1P3/2P4P/3P2PK/R1Q3B1/1r1n2q1 b - - 0 1', '...Ra1 if Rxa1 Nf2+' ],
				['3r2k1/4qppp/p7/1pp1n3/4P3/BP6/P2R1PPP/3Q2K1 b - - 0 1', '...Nf3+ gxf3 Qg5' ],
				['6k1/5p2/6p1/3Q4/3P1K1P/5P2/1P2r1q1/R7 b - - 0 1', '...Qh2+ if Kg5 Qg3+ or if Kg4 Rg2#' ],
				['3rnrk1/1b3pp1/1q2p1P1/p3P3/1p1N4/4Q3/PPP4P/2KR1R2 w - - 0 1', 'Qh3'],
				['8/8/8/2Q5/8/3K4/1k6/q7 w - - 0 1', 'Qb4+'],
				['r3k2r/4b2p/3pBp2/1bq5/1p2P3/3N4/PpP1Q1PP/1K1R1R2 w - - 0 1', 'Rf5 Qb6 Qh5+']
			];
				
		var matePuzzles	= [];
		var materialPuzzles = [];
		var files = ["a", "b", "c", "d", "e", "f", "g", "h"];
		var cleanedSolutions = [];
		var notation = [];
		function findNotation(){
			i=0;
			var letter = ['a','b','c','d','e','f','g','h'];
			while(i<8){
				j=1;
				while (j<=8){
					notation.push(letter[i] + j);
					j++;
				}
				i++;
			}
			return notation;
		};
			
		function findSum(total, num) {
			return total + num;
		};
			
		function initializeBoard() {
			var cfg = {
			  draggable: true,
			  position: 'start',
			  //onDragStart: onDragStart,
			  //onDrop: onDrop,
			  //onSnapEnd: onSnapEnd
			};
			
			board = ChessBoard('board', cfg);
			//board.start;
			//board.move('g1-f3');

		}; // end init()
				
		function enterPosition(){
			var position = {
			 	d6: 'bK',
			  	d4: 'wP',
			  	e4: 'wK',
			  	e1: 'wQ'
			};
			board = ChessBoard('board', position);
		};
			
		function test(){
			var items = [
			  [1, 2],
			  [3, 4],
			  [5, 6]
			];
			var stringList = ["...Delete the dots"];
			//alert(stringList);
			string = stringList[0];
			string = string.replace('...','');
			stringList.push(string);
			//alert(items);
			//alert(items[0][1]);
			//alert(string);
			//alert(stringList);
			
			var temp = "This is a string.";
			var count = (temp.match(/is/g) || []).length;
			console.log(count);
			alert(count);
			alert(temp.match(/is/g) || []);
			
		};
			
			
		function cleanSolutions(){

		};
			
		function sortTactics(){
			for (i = 0; i < tactics.length; i++){
				if (tactics[i][1].indexOf("#") != -1){
					matePuzzles.push(tactics[i][1]);
					if (groupByDifficuty(i) == true){
						hardMates.push(tactics[i][1]);
					}else if (groupByDifficuty(i) == false){
						easyMates.push(tactics[i][1]);
						}
				}else{
					materialPuzzles.push(tactics[i][1]);
				}
			}	
		};
			
		function groupByDifficuty(i){
				if (tactics[i][1].indexOf("if") != -1 && tactics[i][1].indexOf("or") != -1){
					var solWithIf = tactics[i][1];
					solWithIf = solWithIf.replace('if','');
					return true;
				}else if (tactics[i][1].indexOf("if") != -1){
					var solWithIf = tactics[i][1];
					solWithIf = solWithIf.replace('if','');
				}
		};
			
		function loadTactic(){
			var randNum = Math.floor(Math.random() * tactics.length);
			var board,
		  	game = new Chess(tactics[randNum][0]),
		  	statusEl = $('#status'),
		  	fenEl = $('#fen'),
		  	pgnEl = $('#pgn');

			// do not pick up pieces if the game is over
			// only pick up pieces for the side to move
			var onDragStart = function(source, piece, position, orientation) {
			  if (game.game_over() === true ||
				  (game.turn() === 'w' && piece.search(/^b/) !== -1) ||
				  (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
				return false;
			  }
			};

			var onDrop = function(source, target) {
			  // see if the move is legal
				var move = game.move({
					from: source,
					to: target,
					promotion: 'q' // NOTE: always promote to a queen for example simplicity
			  	});

			  	// illegal move
			  	if (move === null) return 'snapback';
			  	updateStatus();
			  	if (game.turn() === 'w') {
			  		validateTacticsMove(source, target);
			  	}
			};

			var validateTacticsMove = function(source, target){
				var boardPositions = board.position();
				var addPoints = false;
				for (var i = tactics.length - 1; i >= 0; i--) {
					var tac = tactics[i]; //['6k1/5p1p/4p1p1/2p1P3/2P4P/3P2PK/R1Q3B1/1r1n2q1 b - - 0 1', '...Ra1 if Rxa1 Nf2+' ]
					var tmpSt = tac[0].split(" ")[1]; // b

					var tmpStr = tac[1].replace("...", ""); // Ra1 if Rxa1 Nf2+
					var rightMove = tmpSt + tmpStr[0]; // bR
					var reqPos = tmpStr[1]+tmpStr[2];
					if (boardPositions[source] === rightMove && target === reqPos ) {
						addPoints = true;
						var botMove = tmpStr;	
						break;
					}
				}
				(addPoints)?console.log('Add Points'):console.log('Deduct Points');
				if (addPoints) {
					playBot(botMove);
				}else{
					//TODO: Bot random moves
				}
				return addPoints;
			};

			//Ra1 if Rxa1 Nf2+
			var playBot = function(botMove){
				//'...Ra1 if Rxa1 Nf2+' ]
				botMove = botMove.split(" ");
				
			};

			// update the board position after the piece snap 
			// for castling, en passant, pawn promotion
			var onSnapEnd = function() {
			  	board.position(game.fen());
			};

			var updateStatus = function() {
			  	var status = '';

			  	var moveColor = 'White';
			  	if (game.turn() === 'b') {
					moveColor = 'Black';
			  	}

			  	// checkmate?
			  	if (game.in_checkmate() === true) {
					status = 'Game over, ' + moveColor + ' is in checkmate.';
			  	}else if (game.in_draw() === true) {
					status = 'Game over, drawn position';
			  	}else {
					status = moveColor + ' to move';
					if (game.in_check() === true) {
				  		status += ', ' + moveColor + ' is in check';
					}
			  	}

			  	statusEl.html(status);
			  	fenEl.html(game.fen());
			  	pgnEl.html(game.pgn());
			};

			updateStatus();	
			var cfg = {
				draggable: true,
				position: tactics[randNum][0],
				onDragStart: onDragStart,
				onDrop: onDrop,
				onSnapEnd: onSnapEnd,
				dropOffBoard: 'snapback'
			};
			board = ChessBoard('board', cfg);
			position = board.position();
		};
		</script>
	</head>
	
	<body id="bodyId" onLoad="initializeBoard()">
		<form name="frmSlope" id="slopeForm">
			
			<br><center><div id="board" style="width: 500px"></div>
			<p>Status: <span id="status"></span></p>
			<p>FEN: <span id="fen"></span></p>
			<p>PGN: <span id="pgn"></span></p></center>
			<input type="button" value="New Tactic" onClick="loadTactic()">
			<input type="button" value="Enter a position" onClick="onDragStart()">
			<input type="button" value="test" onClick=" test()">
			<input type="button" value="clean" onClick=" cleanSolutions()">
			<input type="button" id="startPositionBtn" value="Start Position" />
			<input type="button" id="move1Btn" value="e2-e4" />
			
		</form>
		
		
	</body>
</html>
